# 前端开发规范

---

## 目录

* [声明](#statement)
* [一、编程规约](#programmingProtocol)
	+ [（一）命名规范](#namingConventions)
		- [1.1.1 项目命名](#1.1.1)
		- [1.1.2 目录命名](#1.1.2)
		- [1.1.3 JS、CSS、SCSS、HTML、PNG、JPG文件命名](#1.1.3)
		- [1.1.4 命名严谨性](#1.1.4)
	+ [（二）HTML规范（Vue Template同样适用）](#htmlConventions)
		- [1.2.1 HTML类型](#1.2.1)
		- [1.2.2 缩进](#1.2.2)
		- [1.2.3 分块注释](#1.2.3)
		- [1.2.4 语义化标签](#1.2.4)
		- [1.2.5 引号](#1.2.5)
	+ [（三）CSS规范](#cssConventions)
		- [1.3.1 命名](#1.3.1)
		- [1.3.2 选择器](#1.3.2)
		- [1.3.3 尽量使用缩写属性](#1.3.3)
		- [1.3.4 每个选择器及属性独占一行](#1.3.4)
		- [1.3.5 省略0后面的单位](#1.3.5)
		- [1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式](#1.3.6)
	+ [（四）SCSS规则](#scssConventions)
		- [1.4.1 代码组织](#1.4.1)
			* [1）将公共SCSS文件放置在styles/scss/common文件]()
			* [2）按以下顺序组织]()
		- [1.4.2 避免嵌套层级过多](#1.4.2)
	+ [（五）JavaScript规范](javaScriptConventions)
		- [1.5.1 命名](#1.5.1)
			1. [采用小写驼峰命名lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束]()
			2. [方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式]()
			3. [常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长]()
		- [1.5.2 代码格式](#1.5.2)
			1. [使用2个空格进行缩进]()
			2. [不同逻辑，不同语义、不同业务的代码之间插入一个空行分开来以提升可读性]()
		- [1.5.3 字符串](#1.5.3)
		- [1.5.4 对象声明](#1.5.4)
			1. [使用字面值创建对象]()
			2. [使用字面量来代替对象构造器]()
		- [1.5.5 使用ES6、ES7](#1.5.5)
		- [1.5.6 括号](#1.5.6)
		- [1.5.7 undefined判断](#1.5.7)
		- [1.5.8 条件判断和循环最多三层](#1.5.8)
		- [1.5.9 this的转换命名](#1.5.9)
		- [1.5.10 慎用console.log](#1.5.10)
* [二、Vue项目规范](#vueConventions)
	+ [（一）Vue编码基础](#vueCodingConventions)
		- [2.1.1 组件规范](#2.1.1)
			1. [组件名为多个单词]()
			2. [组件文件名为pascal-case格式]()
			3. [基础组件文件名为base开头，使用完整单词而不是缩写]()
			4. [和父组件紧密耦合的子组件应该以父组件名作为前缀命名]()
			5. [在Template模版中使用组件，应使用PascalCase模式，并且使用自闭合组件]()
			6. [组件的data必须是一个函数]()
			7. [Prop定义应该尽量详细]()
			8. [为组件样式设置作用域]()
			9. [如果特性元素较多，应该主动换行]()
		- [2.1.2 模版中使用简单的表达式](#2.1.2)
		- [2.1.3 指令都使用缩写形式](#2.1.3)
		- [2.1.4 标签顺序保持一致](#2.1.4)
		- [2.1.5 必须为v-for设置key](#2.1.5)
		- [2.1.6 v-show 与v-if选择](#2.1.6)
		- [2.1.7 script标签内部结构顺序](#2.1.7)
		- [2.1.8 Vue Router 规范](#2.1.8)
			1. [页面跳转数据传递使用路由参数]()
			2. [使用路由懒加载（延迟加载）机制]()
			3. [router中的命名规范]()
			4. [router中的path命名规范]()
	+ [（二）Vue项目目录规范](#vueProjectConventions) 
		- [2.2.1 基础](#2.2.1)
		- [2.2.2 使用vue-cli脚手架](#2.2.2)
		- [2.2.3 目录说明](#2.2.3)
			1. [api目录]()
			2. [assets目录]()
			3. [components目录]()
			4. [constants目录]()
			5. [router与store目录]()
			6. [views目录]()
		- [2.2.4 注释说明](#2.2.4)
		- [2.2.5 其他](#2.2.5)
			1. [尽量不要手动操作DOM]()
			2. [删除无用代码]()
* [三、编辑器规范](#ideConventions)
* [四、项目中应用到的插件](#plugins)

## <a href="#statement" id="statement">声明</a>

现代软件架构的复杂性需要协同开发完成，如何高效的协同呢？无规矩不成方圆，无规范难以协同。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性、而是限制过度的个性化，以一种普遍认可的统一方式一起做事，提升写作效率，降低沟通成本。

## <a href="#programmingProtocol" id="programmingProtocol">一、编程规约</a>

### <a href="#namingConventions" id="namingConventions">（一）命名规范</a>

#### <a href="#1.1.1" id="1.1.1">1.1.1 项目命名</a>

全部采用小写方式，以中划线分隔

正例：

```JavaScript
mall-management-system
```

反例：

```JavaScript
mall_management_system / mallManagementSystem
```

#### <a href="#1.1.2" id="1.1.2">1.1.2 目录命名</a>

全部采用小写方式，以中划线分隔，有复数结构时，要采用复数命名法，缩写不用复数

正例：

```JavaScript
scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc
```

反例：

```JavaScript
script / style / demo_scripts / dempStyles / imgs / docs
```

**[特殊]** Vue的项目中components中的组件目录，使用kebab-case

正例：

```JavaScript
head-search / page-loading / authorized / notice-icon
```

反例：

```JavaScript
ShoppingCar / UserManagement
```

#### <a href="#1.1.3" id="1.1.3">1.1.3 JavaScript、CSS、SCSS、HTML、PNG、JPG文件命名</a>

全部采用小写方式，以中划线分隔

正例：

```JavaScript
render-dom.js / signup.css / index.html / company-logo.png / page-bg.jpg
```

反例：

```JavaScript
remderDom.js / UserManagement.html
```

#### <a href="#1.1.4" id="1.1.4">1.1.4 命名严谨性</a>

代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。**[说明]**：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。**[注意]**：即使纯拼音命名方式也要避免采用

正例：

```JavaScript
henan / luoyang / rmb 等国际通用的名称，可视同英文
```

反例：

```JavaScript
DaZhePromotion[打折] / getPingfenByName() [评分] / int 变量 = 3
```

杜绝完全不规范的缩写，避免望文不知义：

<font color="#f40">**[反例]**</font>：AbstractClass “缩写”命名为AbsClass；condition “缩写”命名成condi， 此类随意缩写严重降低了代码的可读性

### <a href="#htmlConventions" id="htmlConventions">HTML规范（Vue Template 同样适用）</a>

#### <a href="#1.2.1" id="1.2.1">1.2.1 HTML类型</a>

推荐使用HTML5的文档类型申明

（建议使用text/html格式的HTML。避免使用XHTML。XHTML以及它的属性，比如application/xhtml+xml在浏览器中应用支持与优化空间都十分有限）

* 规定字符编码
* IE兼容模式
* DOCTYPE大写

正例：

```HTML5
<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Style Guide</title>
		<meta content="telephone=no, email=no" name="format-detection">
		<meta content="email=no" name="format-detection" />
		<meta content="yes" name="apple-mobile-web-app-capable">
		<meta content="black" name="apple-mobile-web-app-status-bar-style">
		<meta http-equiv="Cache-Control" content="no-cache,must-revalidate">
		<meta name="keywords" content="">
		<meta name="description" content="">
		<link rel="apple-touch-icon-precomposed" href="/apple-touch-icon-57x57-precomposed.png">
		<link rel="shortcut icon" href="path/to/favicon.ico">
	</head>
	<body>
		<!-- header，如其名，通常出现在前部，表示导航或者介绍性的内容 -->
		<header>
			<nav></nav>
		</header>
		<!-- 标题组 -->
		<hgroup>
			<h1></h1>
			<h2></h2>
			<h3></h4>
			<h4></h4>
			<h5></h5>
			<h6></h6>
		</hgroup>
		<!-- 表示段落级引述内容,q表示行内的引述内容，cite表示引述的作品名 -->
		
		<blockquote>
			<q></q>
			<cite></cite>
		</blockquote>
		<!-- figure用于表示与主文章相关的图像、照片等流内容figcaption表示内容的标题 -->
		<figure>
			<img src="/example.png" />
			<figcaption></figcaption>
		</figure>
		<!-- dfn用来包裹被定义的名词 -->
		<dfn></dfn>
		<!-- 表示这部分内容是预先排版过的，不需要浏览器进行排版 -->
		<nav>
			<h2></h2>
			<ol></ol>
			<ul></ul>
		</nav>
		<pre>
			<!-- samp计算机程序的示例输出 -->
			<samp></samp>
			<!-- samp计算机程序的示例输出 -->
			<code></code>
		</pre>
		<!-- aside 表示跟文章主体不那么相关的部分，它可能包含导航、广告等工具性质的内容 -->
		<aside>
			<nav></nav>
		</aside>
		<!-- -->
		<section></section>
		<!-- -->
		<article>
			<section></section>
		</article>
		<!-- footer，通常出现在尾部，包含一些作者信息、相关链接、版权信息等 -->
		<footer>
			<address></address>
		</footer>
		<!-- JavaScript -->
		<script src="code-guide.js"></script>
	</body>
</html>
```

#### <a href="#1.2.2" id="1.2.2">1.2.2 缩进</a>

缩进使用2个空格（1个tab）

嵌套的节点应该缩进

#### <a href="#1.2.3" id="1.2.3">1.2.3 分块注释</a>

在每一个块状元素，列表元素和表格元素后，加上一对HTML注释

#### <a href="#1.2.4" id="1.2.4">1.2.4 语义化标签</a>

HTML5中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是`div`或者`p`标签

正例：

```HTML5
<header></header>
<!-- 侧边栏 -->
<aside></aside>

<!-- 文章 -->
<article></article>

<!-- 标题组 -->
<hgroup>
<h1></h1>
<h2></h2>
</hgroup>

<!-- 缩写 -->
<abbr></abbr>

<!-- 横向分隔线 -->
<hr></hr>

<!-- 黑体 -->
<strong></strong>

<!-- 段落级引述内容 -->
<blockquote></blockquote>

<!-- 行内的引述内容 -->
<q></q>

<!-- 引述的作品名 -->
<cite></cite>

<!-- 日期 -->
<time></time>

<!-- 用于表示与主文章相关的图像、照片等流内容，具有一定自包含性（类似独立句子）的内容 -->
<figure>
	<img src="./path/demo.png"/>
	<!-- 内容的标题 -->
	<figcaption>对图片的描述</figcaption>
</figure>

<!-- 被定义的名词 -->
<dfn></dfn>

<!-- 预先排版过的，不需要浏览器进行排版 -->
<pre></pre>

<!-- 计算机程序的示例输出 -->
<samp></samp>

<!--  代码 -->
<code></code>

<!--  补充评论 -->
<small></small>

<!--  错误的内容 -->
<s></s>

<!--  读的时候变调 -->
<i></i>

<!--  关键字 -->
<b></b>

<!--  避免歧义的注记 -->
<u></u>

<!--  跟time标签类似，给机器阅读的内容，意义广泛可以自由定义 -->
<data></data>

<!--  代码 -->
<code></code>

<!--  变量，多用于计算机和数学领域 -->
<var></var>

<!--  用户输入，表示键盘按键居多 -->
<kbd></kbd>

<!--  下标，多用于计算机和数学领域 -->
<sub></sub>

<!--  上标，多用于化学/物理/数学领域 -->
<sup></sup>

<!--  用于多语言混合时指定语言或者书写方向（左到右或者右到左） -->
<bdi></bdi>
<bdo></bdo>

<!--  表示高亮，这里并非指示为高亮，而是从读者角度希望的高量（注意与strong的区别） -->
<mark></mark>

<!--  表示可以换行的位置，主要是英文等文字不允许单词中间换行，这个标签一般在把多个单词粘成很长的单词的时候 -->
<wbr></wbr>

<!--  ul的变体，用于功能菜单时使用 -->
<menu></menu>

<!--  一般出现较为严肃的文章，对一些术语进行定义，dt和dd其实并不总是成对出现，两者时多对多的关系 -->
<dl>
	<dt></dt>
	<dd></dd>
</dl>

<!--  整个页面只出现一个，表示页面的主要内容，可以理解为特殊的div -->
<main></main>

<footer></footer>
```

反例：

```HTML5
<div>
  <p></p>
</div>
```

> 语义化标签的一些点可能会降低开发者的使用欲望：
> 
> 1. 有些标签可能还不知道就已经过时了
> 2. 很多语义标签自带样式，而这些样式我们并不需要，所以还要先取消默认样式
> 3. 现代网页已经不再是按照书籍排版的结构来的，很多页面元素并不容易明确应该使用哪个语义标签

#### <a href="#1.2.5" id="1.2.5">1.2.5 引号</a>

属性值用双引号(`""`)，而不是单引号(`''`)

正例：

```HTML5
<span class="" id="" data-tag="" title=""></span>
```

反例：

```HTML5
<span class='' id='' data-tag='' title="''></span>
```

### <a href="#cssConventions" id="cssConventions">（三）CSS规范</a>

#### <a href="#1.3.1" id="1.3.1">1.3.1 命名</a>

* 类名使用小写字母，以中划线分隔
* ID采用驼峰式命名
* SCSS中的函数、混合、placeholder采用驼峰式命名；变量用小写，单词用`-`中划线链接

ID和class的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称

正例：

```CSS
.heavy {
	font-weight: 800;
}

.important {
	color: red;
}
```

反例：

```CSS
.fw-800 {
	font-weight: 800;
}

.red {
	color: red;
}
```

#### <a href="#1.3.2" id="1.3.2">1.3.2 选择器</a>

1. CSS选择器中避免使用标签名
	* 从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题
2. 很多前端开发人员写选择器的时候不使用直接选择器（**[注]**：直接子选择器和后代选择器的区别）
	* 有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。

正例：

```CSS
.content > .title {
	font-size: 2rem;
}
```

反例：

```CSS
.content .title {
	font-size: 2rem;
}
```

#### <a href="#1.3.3" id="1.3.3">1.3.3 尽量使用缩写属性</a>

正例：

```CSS
.content {
	border-top: 0;
	font: 100%/1.6 palatino, georgia, serif;
	padding: 0 1em 2em;
}
```

反例：

```CSS
.content {
	border-top-style: none;
	font-family: palatino, georgia, serif;
	font-size: 100%;
	line-height: 1.6;
	padding-bottom: 2em;
	padding-left: 1em;
	padding-right: 1em;
	padding-top: 0;
}
```

#### <a href="#1.3.4" id="1.3.4">1.3.4 每个选择器及属性独占一行</a>

正例：

```CSS
.content {
	width:100px;
	height:50px;
	color:#fff;
	background:#00a0e9;
}
```

反例：

```CSS
.content {
	width:100px;height:50px;color:#fff;background:#00a0e9;
}
```

#### <a href="#1.3.5" id="1.3.5">1.3.5 省略0后面的单位</a>

正例：

```CSS
.content {
	padding-bottom: 0;
	margin: 0;
}
```

反例：

```CSS
.content {
	padding-bottom: 0px;
	margin: 0em;
}
```

#### <a href="#1.3.6" id="1.3.6">1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式</a>

正例：

```CSS
.header {
	padding-bottom: 0px;
	margin: 0em;
}
```

反例：

```CSS
#header {
	padding-bottom: 0px;
	margin: 0em;
}
```

### <a href="#scssConventions" id="scssConventions">（四）SCSS规范</a>

#### <a href="#1.4.1" id="1.4.1">1.4.1 代码组织</a>

**1）目录结构**

* `base`：放置一些基本样式的SCSS文件，比如重置样式`_normalize.scss`，基本样式`_base.scss`，文本排版样式`_typography.scss`等
* `components`：放置一些公用组件，比如：按钮`_buttons.scss`、表单`_form.scss`、表格`_tables.scss`、选项卡`_tabs.scss`等
* `helps`：放置一些辅助功能性文件，比如：`_css3.scss`、`_variables.scss`、`_mixins.scss`、`_helpers.scss`和`_function.scss`等
* `layout`：放置一些跟页面布局相关的，比如：`_layout.scss`、`_header.scss`、`_footer.scss`、`_sidbar.scss`等
* `pages`：放置跟具体项目页面相关的样式文件。
* `themes`：对于一些有前后台页面，或者需换肤的项目，就可以将相关文件放置在这里。
* `vendors`：引用的外部插件或者框架的SCSS文件，比如`_bootstrap.scss`、`_foundation.scss`。
* `style.scss`：这是主样式文件，最终编译，就编译这个问题。当然根据项目大小，可做一些其他处理。比如说针对不同的页面,创建不同的`page_xxx.scss`文件。

**2）按以下顺序组织**

1. @import;
2. 变量声明
3. 样式声明

```SCSS
// style.scss

@charset “UTF-8”;

// 功能性文件
@import “helps/variables”;
@import “helps/function”;
@import “helps/mixins”;
@import “helps/helpers”;
@import “helps/css3”;

// 基本样式
@import “base/normalize”;
@import “base/base”;
@import “base/typography”;

// 组件样式
@import “components/buttons”;
@import “components/form”;
@import “components/icons”;
@import “components/labels”;
@import “components/tables”;
@import “components/navigation”;

// 页面布局样式
@import “layout/layout”;
@import “layout/header”;
@import “layout/sidebar”;
@import “layout/footer”;

// 首页额外样式
@import “pages/index”;
```

**3）嵌套顺序**

```SCSS
  .product-teaser {
    // 1. Style attributes
    display: inline-block;
    padding: 1rem;
    background-color: whitesmoke;
    color: grey;

    // 2. Pseudo selectors with parent selector
    &:hover {
      color: black;
    }

    // 3. Pseudo elements with parent selector
    &:before {
      content: "";
      display: block;
      border-top: 1px solid grey;
    }

    &:after {
      content: "";
      display: block;
      border-top: 1px solid grey;
    }

    // 4. State classes with parent selector
    &.active {
      background-color: pink;
      color: red;

      // 4.2. Pseuso selector in state class selector
      &:hover {
        color: darkred;
      }
    }

    // 5. Contextual media queries
    @media screen and (max-width: 640px) {
      display: block;
      font-size: 2em;
    }

    // 6. Sub selectors
    > .content > .title {
      font-size: 1.2em;

      // 6.5. Contextual media queries in sub selector
      @media screen and (max-width: 640px) {
        letter-spacing: 0.2em;
        text-transform: uppercase;
      }
    }
  }
```

#### <a href="#1.4.2" id="1.4.2">1.4.2 避免嵌套层级过多</a>

将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估。这可以避免出现过于详实的CSS选择器。

避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现

正例：

```CSS
.main-title {
	.name {
		color:#fff
	}
}
```

反例：

```SCSS
.main {
	.title {
		.name {
			color:#fff
		}
	}
}
```

### <a href="#javaScriptConventions" id="javaScriptConventions">JavaScript 命名</a>

#### <a href="#1.5.1" id="1.5.1">1.5.1 命名</a>

**1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束**

反例：

```JavaScript
_name / name_ / name$
```

**2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式，构造方法采用大驼峰形式**

正例：

```JavaScript
localValue / getHttpMessage() / inputUserId
```

**[注]**：其中 method 方法命名必须是 动词 或者 动词+名词 形式

正例：

```JavaScript
saveShopCarData / openShopCarInfoDialog
```

反例：

```JavaScript
save / open / show / go
```

**[特此说明]**： 增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）

```
add / update / delete / detail / fetch 
```

**[附]**： 函数方法常用的动词

* `fetch` 获取
* `get` 获取 / `set` 设置,
* `add` 增加 / `remove` 删除
* `create` 创建 / `destroy` 移除
* `start` 启动 / `stop` 停止
* `open` 打开 / `close` 关闭,
* `read` 读取 / `write` 写入
* `load` 载入 / `save` 保存,
* `create` 创建 / `destroy` 销毁
* `begin` 开始 / `end` 结束,
* `backup` 备份 / `restore` 恢复
* `import` 导入 / `export` 导出,
* `split` 分割 / `merge` 合并
* `inject` 注入 / `extract` 提取,
* `attach` 附着 / `detach` 脱离
* `bind` 绑定 / `separate` 分离,
* `view` 查看 / `browse` 浏览
* `edit` 编辑 / `modify` 修改,
* `select` 选取 / `mark` 标记
* `copy` 复制 / `paste` 粘贴,
* `undo` 撤销 / `redo` 重做
* `insert` 插入 / `delete` 移除,
* `add` 加入 / `append` 添加
* `clean` 清理 / `clear` 清除,
* `index` 索引 / `sort` 排序
* `find` 查找 / `search` 搜索,
* `increase` 增加 / `decrease` 减少
* `play` 播放 / `pause` 暂停,
* `launch` 启动 / `run` 运行
* `compile` 编译 / `execute` 执行,
* `debug` 调试 / `trace` 跟踪
* `observe` 观察 / `listen` 监听,
* `build` 构建 / `publish` 发布
* `input` 输入 / `output` 输出,
* `encode` 编码 / `decode` 解码
* `encrypt` 加密 / `decrypt` 解密,
* `compress` 压缩 / `decompress` 解压缩
* `pack` 打包 / `unpack` 解包,
* `parse` 解析 / `emit` 生成
* `connect` 连接 / `disconnect` 断开,
* `send` 发送 / `receive` 接收
* `download` 下载 / `upload` 上传,
* `refresh` 刷新 / `synchronize` 同步
* `update` 更新 / `revert` 复原,
* `lock` 锁定 / `unlock` 解锁
* `check out` 签出 / `check in` 签入,
* `submit` 提交 / `commit` 交付
* `push` 推 / `pull` 拉,
* `expand` 展开 / `collapse` 折叠
* `begin` 起始 / `end` 结束,
* `start` 开始 / `finish` 完成
* `enter` 进入 / `exit` 退出,
* `abort` 放弃 / `quit` 离开
* `obsolete` 废弃 / `depreciate` 废旧,
* `collect` 收集 / `aggregate` 聚集

**3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。**

正例：

```JavaScript
MAX_STOCK_COUNT
```

反例：

```JavaScript
MAX_COUNT
```

#### <a href="#1.5.2" id="1.5.2">1.5.2 代码格式</a>

**1) 使用 2 个空格进行缩进**

正例：

```JavaScript
if (x < y) {
	x += 10;
} else {
	x += 1;
}
```

**2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。**

> **[说明]**：任何情形，没有必要插入多个空行进行隔开。

#### <a href="#1.5.3" id="1.5.3">1.5.3 字符串</a>

统一使用单引号(')，不使用双引号(")。这在创建 HTML 字符串非常有好处

正例：

```JavaScript
let str = 'foo';
let testDiv = '<div id="test"></div>';
```

反例：

```JavaScript
let str = 'foo';
let testDiv = "<div id='test'></div>";
```

#### <a href="#1.5.4" id="1.5.4">1.5.4 对象声明</a>

**1)使用字面值创建对象**

正例：

```JavaScript
let user = {};
```

反例：

```JavaScript
let user = new Object();
```

**2) 使用字面量来代替对象构造器**

正例：

```JavaScript
var user = {
	age: 0,
	name: 1,
	city: 3
};
```

反例：

```JavaScript
var user = new Object();
user.age = 0;
user.name = 0;
user.city = 0;
```

#### <a href="#1.5.5" id="1.5.5">1.5.5 使用 ES6、7...</a>

必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用

> 必须强制使用 ES6, ES7 的新语法，比如箭头函数、await / async ， 解构， let ， for…of 等等

#### <a href="#1.5.6" id="1.5.6">1.5.6 括号</a>

下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。

正例：

```JavaScript
if (condition) {
	doSomething();
}
```

反例：

```JavaScript
if (condition) doSomething();
```

#### <a href="#1.5.7" id="1.5.7">1.5.7 `undefined` 判断</a>

永远不要直接使用 `undefined` 进行变量判断；使用 `typeof` 和字符串`undefined`对变量进行判断。

正例：

```JavaScript
if (typeof person === 'undefined') {
	...
}
```

反例：

```JavaScript
if (person === undefined) {
	...
}
```

#### <a href="#1.5.8" id="1.5.8">1.5.8 条件判断和循环最多三层</a>

条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。

#### <a href="#1.5.9" id="1.5.9">1.5.9 this 的转换命名</a>

对上下文 `this` 的引用只能使用`self`来命名

#### <a href="#1.5.10" id="1.5.10">1.5.10 慎用 `console.log`</a>

因 `console.log` 大量使用会有性能问题，所以在非 `webpack` 项目中谨慎使用 `log` 功能

## <a href="#vueConventions" id="vueConventions">二、Vue 项目规范</a>

### <a href="#vueCodingConventions" id="vueCodingConventions">（一）Vue编码基础</a> 

vue 项目规范以 Vue 官方规范 （[Vue.js风格指南](https://cn.vuejs.org/v2/style-guide/)） 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。

#### <a href="#2.1.1" id="2.1.1">2.1.1 组件规范</a>

**1) 组件名为多个单词**

组件名应该始终是多个单词组成（大于等于 2），且命名规范为`KebabCase`格式。

这样做可以避免跟现有的以及未来的 `HTML` 元素相冲突，因为所有的 `HTML` 元素名称都是单个单词的。

正例：

```Vue
export default {
	name: 'TodoItem'
	// ...
}
```

反例：

```Vue
export default {
	name: 'Todo',
	// ...
}

export default {
	name: 'todo-item',
	// ...
}
```

**2) 组件文件名为 pascal-case 格式**

正例：

```Vue
components/
|- my-component.vue
```

反例：

```Vue
components/
|- myComponent.vue
|- MyComponent.vue
```

**3) 基础组件文件名为 base 开头，使用完整单词而不是缩写**

正例：

```Vue
components/
|- base-button.vue
|- base-table.vue
|- base-icon.vue
```

反例：

```Vue
components/
|- MyButton.vue
|- VueTable.vue
|- Icon.vue
```

**4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名**

正例：

```Vue
components/
|- todo-list.vue
|- todo-list-item.vue
|- todo-list-item-button.vue
|- user-profile-options.vue （完整单词）
```

反例：

```Vue
components/
|- TodoList.vue
|- TodoItem.vue
|- TodoButton.vue
|- UProfOpts.vue （使用了缩写）
```

**5) 在 Template 模版中使用组件，应使用 `PascalCase` 模式，并且使用自闭合组件**

正例：

```Vue
<!-- 在单文件组件、字符串模板和 JSX 中 -->
<MyComponent />
<Row>
	<table :column="data"/>
</Row>
```

反例：

```Vue
<my-component />
<row>
	<table :column="data"/>
</row>
```

**6) 组件的 data 必须是一个函数**

当在组件中使用 `data` 属性的时候 (除了 `new Vue` 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响

正例：

```Vue
export default {
	data () {
		return {
			name: 'jack'
		}
	}
}
```

反例：

```Vue
export default {
	data: {
		name: 'jack'
	}
}
```

**7) Prop 定义应该尽量详细**

* 必须使用 `camelCase` 驼峰命名
* 必须指定类型
* 必须加上注释，表明其含义
* 必须加上 `required` 或者 `default`，两者二选其一
* 如果有业务需要，必须加上 `validator` 验证

```Vue
 props: {
	// 组件状态，用于控制组件的颜色
	status: {
		type: String,
		required: true,
		validator: function (value) {
			return [
				'succ',
				'info',
				'error'
			].indexOf(value) !== -1
		}
	},
	// 用户级别，用于显示皇冠个数
	userLevel：{
		type: String,
		required: true
	}
}
```

**8) 为组件样式设置作用域**

正例：

```Vue
<template>
	<button class="btn btn-close">X</button>
</template>

<!-- 使用 `scoped` 特性 -->
<style scoped>
	.btn-close {
		background-color: red;
	}
</style>
```

反例：

```Vue
<template>
	<button class="btn btn-close">X</button>
</template>
<!-- 没有使用 `scoped` 特性 -->
<style>
	.btn-close {
		background-color: red;
	}
</style>
```

**9) 如果特性元素较多，应该主动换行**

正例：

```Vue
<MyComponent 
	foo="a" 
	bar="b" 
	baz="c"
/>
```

反例：

```Vue
<MyComponent foo="a" bar="b" baz="c" />
```

#### <a href="#2.1.2" id="2.1.2">2.1.2 模板中使用简单的表达式</a>

组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用

正例：

```Vue
<template>
	<p>{{ normalizedFullName }}</p>
</template>

<script>
// 复杂表达式已经移入一个计算属性
computed: {
	normalizedFullName () {
		return this.fullName.split(' ').map(function (word) {
			return word[0].toUpperCase() + word.slice(1)
		}).join(' ')
	}
}
</script>
```

反例：

```Vue
<template>
	<p>
		{{
			fullName.split(' ').map(function (word) {
				return word[0].toUpperCase() + word.slice(1)
			}).join(' ')
		}}
	</p>
</template>
```

#### <a href="#2.1.3" id="2.1.3">2.1.3 指令都使用缩写形式</a>

指令推荐都使用缩写形式，(用 `:` 表示 `v-bind:`、用 `@` 表示 `v-on:` 和用 `#` 表示 `v-slot:`)

正例：

```Vue
<input
	@input="onInput"
	@focus="onFocus"
>
</script>
```

反例：

```Vue
<input
	v-on:input="onInput"
	@focus="onFocus"
>
```

#### <a href="#2.1.4" id="2.1.4">2.1.4 标签顺序保持一致</a>

单文件组件应该总是让标签顺序保持为

正例：

```Vue
<template>...</template>
<script>...</script>
<style>...</style>
```

反例：

```Vue
<template>...</template>
<style>...</style>
<script>...</script>
```

#### <a href="#2.1.5" id="2.1.5">2.1.5 必须为 v-for 设置键值 key</a>

#### <a href="#2.1.6" id="2.1.6">2.1.6 v-show 与 v-if 选择</a>

如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。

#### <a href="#2.1.7" id="2.1.7">2.1.7 script 标签内部结构顺序</a>

```Vue
components > name > props > data > computed > watch > filter > 钩子函数（钩子函数按其执行顺序） > methods
```

#### <a href="#2.1.8" id="2.1.8">2.1.8 Vue Router 规范</a>

**1) 页面跳转数据传递使用路由参数**

页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据

正例：

```Vue
let id = ' 123'
this.$router.push({ 
	name: 'userCenter', 
	query: { 
		id 
	} 
})
```

**2) 使用路由懒加载（延迟加载）机制**

```
{
	path: '/uploadAttachment',
	name: 'uploadAttachment',
	meta: {
		title: '上传附件'
	},
	component: () => import('@/view/components/uploadAttachment/index.vue')
},
```

**3) router 中的命名规范**

path、childrenPoints 命名规范采用`kebab-case`命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是`kebab-case`，这样很方便找到对应的文件）

name 命名规范采用`KebabCase`命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）

```JavaScript
// 当设置 true 的时候该路由不会在侧边栏出现 如401，login等页面，或者如一些编辑页面/edit/1
hidden: true // (默认 false)

//当设置 noRedirect 的时候该路由在面包屑导航中不可被点击
redirect: 'noRedirect'

// 当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式--如组件页面
// 只有一个时，会将那个子路由当做根路由显示在侧边栏--如引导页面
// 若你想不管路由下面的 children 声明的个数都显示你的根路由
// 你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由
alwaysShow: true

name: 'router-name' // 设定路由的名字，一定要填写不然使用<keep-alive>时会出现各种问题
meta: {
	routerId: '1' // 设置该路由进入的权限，支持多个权限叠加
	title: 'title' // 设置该路由在侧边栏和面包屑中展示的名字
	icon: 'svg-name' // 设置该路由的图标，支持 svg-class，也支持 el-icon-x element-ui 的 icon
	noCache: true // 如果设置为true，则不会被 <keep-alive> 缓存(默认 false)
	breadcrumb: false //  如果设置为false，则不会在breadcrumb面包屑中显示(默认 true)
	affix: true // 若果设置为true，它则会固定在tags-view中(默认 false)
	
	// 当路由设置了该属性，则会高亮相对应的侧边栏。
	// 这在某些场景非常有用，比如：一个文章的列表页路由为：/article/list
	// 点击文章进入文章详情页，这时候路由为/article/1，但你想在侧边栏高亮文章列表的路由，就可以进行如下设置
	activeMenu: '/article/list'
}
```

正例：

```Vue
{
	path: '/permission',
	component: Layout,
	redirect: '/permission/index', //重定向地址，在面包屑中点击会重定向去的地址
	hidden: true, // 不在侧边栏线上
	alwaysShow: true, //一直显示根路由
	meta: { 
		routerId: '1' 
	}, //你可以在根路由设置权限，这样它下面所以的子路由都继承了这个权限
	children: [{
		path: 'index',
		component: ()=>import('permission/index'),
		name: 'permission',
		meta: {
			title: 'permission',
			icon: 'lock', // 图标
			routerId: '1' , // 或者你可以给每一个子路由设置自己的权限
			affix: true,  // 是否在tags-view 显示
			breadcrumb: false, // 是否在面包屑breadcrumb导航中显示
			noCache: true // 不会被 <keep-alive> 缓存
		}
	}]
}
```

**[目的]**：经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件

**4) router 中的 path 命名规范**

`path`除了采用`kebab-case`命名规范以外，必须以 / 开头，即使是`children`里的`path`也要以 `/` 开头

### <a href="#vueProjectConventions" id="vueProjectConventions">（二）Vue项目目录规范</a>

#### <a href="#2.2.1" id="2.2.1">2.2.1 基础</a>

vue 项目中的所有命名一定要与后端命名统一

比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词

#### <a href="#2.2.2" id="2.2.2">2.2.2 使用 Vue-cli 脚手架</a>

使用 vue-cli3 来初始化项目，项目名按照上面的命名规范

#### <a href="#2.2.3" id="2.2.3">2.2.3 目录说明</a>

目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名

```Bash
mock                                mock接口服务
src                                   源码目录
|-- api                              所有api接口
|-- assets                         静态资源，images, icons 等
|-- components                 公用组件
|-- constants                    常量信息，项目所有Enum, 全局常量等
|-- directives                    自定义指令
|-- lang                            国际化i18n
|-- filters                          过滤器，全局工具
|-- layout                         架构
|-- plugins                       外部引用的插件存放及修改文件
|-- mock                         模拟接口，临时存放
|-- router                         路由，统一管理
|-- store                          vuex, 统一管理
|-- styles                         SCSS样式
|-- services                     数据请求服务      
|-- utils                          常用工具方法   
|-- views                         视图目录
|   |-- dashboard              首页    
|-- App.vue                     入口文件
|-- main.js                      入口js
```

**1) api 目录**

* 文件、变量命名要与后端保持一致。
* 此目录对应后端 API 接口，按照后端一个 `controller` 一个 `api` `js` 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。
* API 中的方法名字要与后端 `api` `url` 尽量保持语义高度一致性。
* 对于 API 中的每个方法要添加注释，注释与后端 API 文档保持一致

**2) assets 目录**

assets 为静态资源，里面存放 images, icons 等静态资源，静态资源命名格式为 kebab-case

**3) components 目录**

此目录应按照组件进行目录划分，目录命名为 `kebab-case`，组件命名规则也为 `kebab-case`

**4) constants 目录**

此目录存放项目所有常量

> 参考：使用 vue-enum 插件([https://www.npmjs.com/package/vue-enum](https://www.npmjs.com/package/vue-enum))

**5) router 与 store 目录**

这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。

router 尽量按照 views 中的结构保持一致

store 按照业务进行拆分不同的 js 文件

**6) views 目录**

命名要与后端、router、api 等保持一致

components 中组件要使用 PascalCase 规则

#### <a href="#2.2.4" id="2.2.4">2.2.4 注释说明</a>

整理必须加注释的地方

* 公共组件使用说明
* api 目录的接口 js 文件必须加注释
* store 中的 state, mutation, action 等必须加注释
* vue 文件中的 template 必须加注释，若文件较大添加 start end 注释
* vue 文件的 methods，每个 method 必须添加注释
* vue 文件的 data, 非常见单词要加注释

#### <a href="#2.2.5" id="2.2.5">2.2.5 其他</a>

**1) 尽量不要手动操作 DOM**

因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等

**2) 删除无用代码**

因使用了 git/svn 等代码版本工具，对于无用代码必须及时删除

## <a href="#ideConventions" id="ideConventions">三、编辑器规范</a>

### 开发IDE

Vs Code

### Vs Code 编辑器配置

```JSON
// settings.json // Vs Code 编辑器配置 可以参考
{
    "editor.detectIndentation": false,
    "editor.codeActionsOnSave": {
        "source.fixAll.eslint": true
    },
    "editor.fontFamily": "Menlo, Monaco, 'Courier New', monospace, 'Meslo LG M for Powerline'",
    "emmet.includeLanguages": {
        "javascript": "javascriptreact",
        "vue-html": "html",
        "razor": "html",
        "plaintext": "jade"
    },
    "emmet.triggerExpansionOnTab": true,
    "eslint.validate": [
        "vue",
        "html",
        "javascript",
        "typescript",
        "javascriptreact",
        "typescriptreact"
    ],
    "eslint.alwaysShowStatus": true,
    "files.autoSave": "onFocusChange",
    "javascript.format.insertSpaceBeforeFunctionParenthesis": true,
    "javascript.format.semicolons": "remove",
    "javascript.preferences.quoteStyle": "single",
    "prettier.jsxSingleQuote": true,
    "prettier.semi": false,
    "prettier.singleQuote": true,
    "vetur.format.defaultFormatter.js": "vscode-typescript",
    "vetur.format.defaultFormatter.html": "prettier",
    "vetur.format.defaultFormatter.css": "prettier",
    "vetur.format.defaultFormatter.postcss": "prettier",
    "vetur.format.defaultFormatter.scss": "prettier",
    "vetur.format.defaultFormatter.less": "prettier",
    "vetur.format.defaultFormatter.stylus": "stylus-supremacy",
    "vetur.format.defaultFormatter.ts": "prettier",
    "vetur.format.defaultFormatter.sass": "sass-formatter",
    "vetur.format.defaultFormatterOptions": {
        //beautify设置
        "js-beautify-html": {
            "wrap_attributes_indent_size": 2,
            "wrap_attributes": "force-expand-multiline" // auto|force|force-aligned|force-expand-multiline
        }
    },
    "window.zoomLevel": 0,
    "workbench.iconTheme": "material-icon-theme",
    "[javascript]": {
        "editor.defaultFormatter": "esbenp.prettier-vscode"
    },
    "csscomb.formatOnSave": true,
    "csscomb.preset": "./.csscomb.json",
    "csscomb.syntaxAssociations": {
        "postcss": "scss"
    },
    "csscomb.ignoreFilesOnSave": [
        "csscomb.formatOnSave"
    ],
    "explorer.confirmDelete": false
}
```

### 关于EditConfit

* 作用：用于解决不同运行环境，不同编辑器运行同一个项目的差异。
* 如何生效：EditorConfig插件（我的是"EditorConfig for VS code"）会在打开的文件的目录中查找名为.editorConfig的文件。然后读取文件中的属性，按先后顺序执行。
* 代码（属性不区分大小写）

```
# https://editorconfig.org
# 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件
root = true

[*]
# 编码
charset = utf-8
# 设置缩进风格，tab或者空格。tab是hard tabs，space为soft tabs
indent_style = space
# 缩进的宽度
indent_size = 2
# 换行符，lf、cr和crlf
end_of_line = lf
# 设为true表明使文件以一个空白行结尾
insert_final_newline = true
# 设为true表示会除去换行行首的任意空白字符
trim_trailing_whitespace = true

[*.md]
insert_final_newline = false
trim_trailing_whitespace = false
```

### 关于Eslint

ESLint 能够检测出代码中的潜在问题，解决代码质量问题

```
"@vue/cli-plugin-eslint": "~4.4.0",
"@vue/eslint-config-prettier": "^6.0.0",
"babel-eslint": "^10.1.0",
"eslint": "^6.7.2",
"eslint-config-vuetify": "^0.6.1",
"eslint-plugin-prettier": "^3.1.3",
"eslint-plugin-vue": "^6.2.2",
```

```JavaScript
//.eslintrc.js 有助于强制执行某些规则，具体rule可以调整
/**
 * 参考文档
 * 【eslint英文文档】https://eslint.org/docs/user-guide/configuring
 * 【eslint中文文档】http://eslint.cn/docs/rules/
 */

/**
 * eslint使用方法
 * 【1】JS代码中通过注释的方式使用
 * 【2】通过Webpack的eslintConfig字段设置，eslint会自动搜索项目的package.json文件中的配置
 * 【3】通过配置文件的方式使用，配置文件有多种文件方式，如JavaScript、JSON或者YAML等
 */

/**
* 文件忽略
* 【】让eslint跳过特定文件的检测
* 【】通过当前工作目录下，「.eslintignore」 文件进行设置
*   其使用的是Glob路径书写方式，与「.eslintignore」的使用方式相同
* 【】也可以在package.json文件中，通过eslintIgnore参数进行设置
*/

/**
 * 文件内局部设置
 * 【】eslint可以具体文件中设置特定代码的规则，常用于跳过某条语句的检测。
 * 【】注销全部规则，在代码前新建一行，添加注销 \/* eslint-disable *\/ 如果没有恢复设置的语句，则下列全部代码都会跳过检测
 * 【】恢复eslint，在代码前新建一行，添加注销 \/* eslint-enable *\/
 * 【】指定忽略的规则，\/* eslint-disable no-alert, no-console *\/ eslint-disable-lines
 * 【】在特定行禁用 \/\/eslint-disable-line
 * 【】在下一行禁用 \/\/ eslint-disable-next-line
 */
module.exports = {
  /**
   * 根目录标识
   * http://eslint.cn/docs/user-guide/configuring#using-configuration-files
   * http://eslint.cn/docs/user-guide/configuring#configuration-cascading-and-hierarchy
   * 【】标识当前配置文件为最底层的文件，无需往更上一级的文件目录中进行搜索
   * 【】默认eslint的配置文件搜索方式，从目标文件夹进行搜索，遍历内部每一个文件夹，找到配置文件并层叠使用。再跳出本项目，往祖先文件夹进行遍历
   * 【】注意「~/.eslintrc」的意义，「~」是指linux上的家目录，「~/.eslintrc」是指家目录下的eslint配置文件，用于私人开发者，用于整个电脑全局约束的。这个配置通过本配置项root去设置，设置了root，eslint检测时将不再往上搜索
   * eslint的生效规则是就近使用，越近的配置项优先级越高，覆盖其他配置项。如果一个项目中，可以在不同文件夹中都添加配置文件，这些规则将重叠组合生效
   */
  // 指定配置文件根目录：表示当前文件为eslint的根配置文件，逐层查找时无需往更上一级的文件目录中进行搜索
  root: true,
  /**
   * 解析器
   * http://eslint.cn/docs/user-guide/configuring#specifying-parser
   * 【】ESlint默认使用Espree作为其解析器
   * 【】解析器必须是本地安装的一个npm模块。即必须按照在本地的node_module中
   * 【】解析器是用于解析JS代码的，怎么去理解每一个表达式，有点C++中编译的概念，会对JS进行一些语法分析，语义分析什么的，才能判断语句符不符合规范。而不是通过简单的字符串对比。
   * 【】解析器有很多，但兼容eslint的解析器有以下几个
   * 【】Espree：默认解析器，一个从Esprima中分离出来的解析器，做了一些优化
   * 【】Esprima：JS标准解析器
   * Babel-ESlint：一个对Babel解析器的包装，babel本身也是JS解析器的一种（不然怎么能转化为兼容性代码呢？首先需要进行JS解析，才能转化）。如果我们的代码需要经过babel转化，则对应使用这个解析器
   * typescript-eslint-parser（实验）-一个把TypeScript转换为ESTree兼容格式的解析器
   * 【】但是通常在vue项目中，并不会写在parser字段中，而是写在parserOptions -> parser。具体原因在parserOptions一栏中介绍
   */
  // parser: 'babel-eslint',
  /**
   * eslint解析器配置项
   * http://eslint.cn/docs/user-guide/configuring#specifying-parser-options
   * 【】这里设置的配置项将会传递到解析器中，被解析器获取到，进行一定的处理。具体被利用到，要看解析器的源码有没有对其进行利用。这里仅仅做了参数定义，做了规定，告诉解析器的开发者可能有这些参数
   * 配置项有
   * 
   * "sourceType": "module", // 指定JS代码来源的类型，script（script标签引入？）｜module（ES6的module模块），默认为script。为什么vue的会使用script呢？因为vue是 通过babel-loader编译的，而babel编译后的代码就是script方式
   * "ecmaVersion": 6, // 支持的ES语法版本，默认为5.注意只是语法，不包括ES的全局变量。全局变量需要在env选项中进行定义
   * "ecmaFeatures": { // Features是特征的意思，这里用于指定要使用其他哪些语言对象
   *  "experimentalObjectRestSpread": true, // 启用对对象的扩展
   *  "jsx": true, // 启用jsx语法
   *  "globalReturn": true, // 允许return在全局使用
   *  "impliedStrict": true //启用严格校验模式
   * }
   * 
   */
  parserOptions: {
    /**
     * 这里出现 parser的原因
     * 【】官方说明中，parserOptions的配置参数是不包括parser的
     * 【】这里parser是eslint-plugin-vue的要求，是eslint-plugin-vue的定义参数
     * 【】根据官方文档，eslint-plugin-vue插件依赖「vue-eslint-parser」解析器。「vue-eslint-parser」解析器只解析.vue中html部分的内容，不会检测<script>中的JS内容
     * 【】由于解析器只有一个，用了「vue-eslint-parser」就不能用「babel-eslint」。所以「vue-eslint-parser」的做法是在解析器选项中，再传入一个解析器选项parser。从而在内部处理「babel-eslint」，检测<script>中的JS代码
     * 【】所以这里出现了parser
     * 【】相关文档地址，https://vuejs.github.io/eslint-plugin-vue/user-guide/#usage
     */
    ecmaVersion: 2017,
    parser: 'babel-eslint',
    // 指定js的导入方式，module是指通过模块导入，默认值为script(表示通过script标签引入)
    sourceType: 'module'
  },
  /**
   * 运行环境
   * http://eslint.cn/docs/user-guide/configuring#specifying-environments
   * 【】一个环境定义了一组预定义的全局变量
   * 【】获得了特定环境的全局定义，就不会认为是开发定义的，跳过对其的定义检测。否则会被认为改变量未定义
   * 【】常见的运行环境有以下这些：
   * browser-浏览器环境中的全局变量
   * node-NodeJS全局变量和NodeJS作用域
   * es6-启用除了modules以外的所有ECMAScript6特性（该选项会自动设置ECMAVersion解析器选项为6）
   * amd-将require()和define()定义为像AMD一样的全局变量
   * commonjs-CommonJS全局变量和CommonJS作用域（用于Browserify/WebPack打包的只在浏览器中运行的代码）
   * jquery-JQuery全局变量
   * mongo-MongoDB全局变量
   * worker-Web Workers全局变量
   * serviceworker-Service Worker
   */
  env: {
    browser: true, // 浏览器环境
    node: true, // NodeJS环境
    es6: true // ES6
  },
  /**
   * 全局变量
   * http://eslint.cn/docs/suer-guild/configuring#specifying-globals
   * 【】定义额外的全局，开发者自定义的全局变量，让其跳过no-undef规则
   * 【】key值就是额外添加的全局变量
   * 【】value值用于标识该变量能否被重写，类似于const的作用。true为允许变量被重写
   * 【】注意：要启用no-global-assign规则来禁止对全局变量进行修改
   */
  globals: {
    // gTool: true, //例如定义gTool这个全局变量，且这个变量可以被重写
  },

  /**
   * 插件
   * http://eslint.cn/docs/user-guide/configuring#configuring-plugins
   * 【】插件同样需要在node_module中下载
   * 【】注意插件名忽略了「eslint-plugin-」前缀，所以在package.json中，对应的项目名是「eslint-plugin-vue」
   * 【】插件的作用类似于解析器，用以扩展解析器的功能，用以检测非常规的JS代码。也可能会新增一些特定的规则
   * 【】如eslint-plugin-vue，是为了帮助我们检测.vue文件中<templates>和<script>中的JS代码
   */
  plugins: ['vue'],

  /**
   * 规则继承
   * http://eslint.cn/docs/user-guide/configuring#extending-configuration-files
   * 【】可以继承的方式有以下几种
   * 【】eslint内置推荐规则，就只有一个，即「eslint:recommended」
   * 【】可共享的配置，是一个npm包，它输出一个配置对象。即通过npm安装的包名是node_module中
   *  可共享的配置可以省略包名的前缀eslint-config-，即实际设置安装的包名是eslint-config-airbnb-base
   * 【】从插件中获取的规则，书写规则为「plugin:插件包名/配置名」,其中插件包名也是可以忽略「eslint-plugin-」前缀。如‘plugin:vue/essential’
   * 【】从配置文件中继承，即继承另外的一个配置文件，如'./node_modules/coding-standard/eslintDefaults.js'
   */
  extends: [
    /**
     * vue的额外添加的规则是v-if，v-else等指令检测
     */
    // 'plugin:vue/essential', // 额外添加的规则可以查看 https://vuejs.github.io/eslint-plugin-vue/rules/

    // 使用 ESLint 的推荐配置
    'plugin:vue/recommended',
    // eslint内置推荐规则「eslint:recommended」
    'eslint:recommended',
    // 插件名称，省略了[eslint-plugin-]前缀，表示规范html
    // 'vuetify'
  ],

  /**
   * 规则共享参数
   * http://eslint.cn/docs/user-guide/configuring#adding-shared-settings
   * 【】提供给具体规则项，每个参数值，每个规则项都会被注入该变量，但对应规则而言，有没有用，就看各个规则的设置了，就好比parserOptions，解析器用不用它就不知道了。这里只是提供这个方法
   * 【】不用怀疑，经源码验证，这就是传递给每个规则项的，会当作参数传递过去，但用不用，就是具体规则的事情
   */
  settings: {
    /**
     * 注意，「import/resolver」并不是eslint规则项，与rules中的「import/extensions」不同。它不是规则项
     * 这里只是一个参数名，叫「import/resolver」，会传递给每个规则项
     * settings并没有具体的书写规则，「import/」只是import模块自己起的名字，原则上，它直接命名为「resolver」也可以，加上「import」只是为了更好的区分。不是强制设置的
     * 因为「import」插件很多规则项都用的这个配置项，所以并没有通过rules设置，而是通过settings共享
     * 具体使用方法可以参考https://github.com/benmosher/eslint-plugin-import
     */
    'import/resolver': {
      /**
       * 这里传入webpack并不是import插件能识别webpack，而且通过npm安装了「eslint-import-resolver-webpack」
       * 「import」插件通过「eslint-import-resolver-」+「webpack」找到该插件并使用，就能解析webpack配置项。使用里面的参数
       * 主要是使用以下这些参数，共享给import规则，让其正确识别import路径
       * extensions: ['.js', '.vue', '.json']
       * alias: {
       *  'vue$': 'vue/dist/vue.esm.js',
       *  '@': resolve('src'),
       *  'static': resolve('static')
       * }
       */
      // webpack: {
      //   config: 'build/webpack.base.conf.js'
      // }
    }
  },
  /**
   * 针对特定文件的配置
   * 【】可以通过overrides对特定文件进行特定的eslint检测
   * 【】特定文件的路径书写使用Glob格式，一个类似正则的路径规则，可以匹配不同的文件
   * 【】配置几乎与ESLint的其他配置相同。覆盖块可以包含常规配置中的除了extends、overrides和root之外的其他任何有效配置选项
   */
  // overrides: [
  //   {
  //     'files': ['bin/*.js', 'lib/*.js'],
  //     'excludedFiles': '*.test.js',
  //     'rules': {
  //       'quotes': [2, 'single']
  //     }
  //   }
  // ],
  /**
   * 自定义规则
   * http://eslint.cn/docs/user-guide/configuring#configuring-rules
   * https://github.com/vuejs/eslint-config-vue
   * 【】基本使用方式
   *  "off"或者0关闭规则
   *  "warn"或者1将规则打开为警告（不影响退出代码）
   *  "error"或者2将规则打开为错误（触发时退出代码为1）
   * 如：'no-restricted-syntax': 0,表示关闭该规则
   * 【】如果某项规则，有额外的选项，可以通过数组进行传递，而数组的第一位必须是错误级别。如0,1,2
   * 如 'semi': ['error', 'never']， never就是额外的配置项
   */
  rules: {
    /**
     * 具体规则
     * 【】具体的规则太多，就不做介绍了，有兴趣的同学可以上eslint官网查
     * 【】注意 xxx/aaa 这些规则是 xxx 插件自定的规则，在eslint官网是查不到的。需要到相应的插件官网中查阅
     * 【】如 import/extensions，这是「eslint-plugin-import」自定义的规则，需要到其官网查看 https://github.com/benmosher/eslint-plugin-import
     */
    /**
     * 逻辑错误及最佳实践的规则
     */
    // 禁止 for 循环出现方向错误的循环，比如 for (i = 0; i < 10; i--)
    'for-direction': 'error',
    // 打包时禁止debugger
    'no-debugger': process.env.NODE_ENV === 'production' ? 2 : 0,
    // 打包时禁止console
    'no-console': process.env.NODE_ENV === 'production' ? 2 : 0,
    // 打包时禁止console
    'no-alert': process.env.NODE_ENV === 'production' ? 2 : 0,
    // 禁止将 await 写在循环里，因为这样就无法同时发送多个异步请求了
    // @off 要求太严格了，有时需要在循环中写 await
    'no-await-in-loop': 'off',
    // 禁止在 if, for, while 里使用赋值语句，除非这个赋值语句被括号包起来了
    'no-cond-assign': [
        'error',
        'except-parens'
    ],
    // 禁止在函数参数中出现重复名称的参数
    'no-dupe-args': 'error',
    // 禁止在对象字面量中出现重复名称的键名
    'no-dupe-keys': 'error',
    // 禁止将常量作为 if, for, while 里的测试条件，比如 if (true), for (;;)，除非循环内部有 break 语句
    'no-constant-condition': [
        'error',
        {
            checkLoops: false
        }
    ],
    // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，
    // always-multiline：多行模式必须带逗号，单行模式不能带逗号
    'comma-dangle': ['error', 'always-multiline'],
    // 'max-len': 'off',
    "max-len": [2, { // 强制行的最大长度
      "code": 200,
      "tabWidth": 2,
      "ignoreUrls": true,
      "ignoreTrailingComments": true,
      "ignoreTemplateLiterals": true,
    }],
    // 强制使用一致的缩进
    'indent': 'off',
    // Workaround for ESLint failing to parse files with template literals
    // with this error: "TypeError: Cannot read property 'range' of null"
    // 强制模板字符串中空格的使用
    'template-curly-spacing': 'off',
    // 在模板中强制组件命名样式的特定大小写
    'vue/component-name-in-template-casing': ['error', 'kebab-case'],
    // 在<script>中强制一致缩进
    'vue/script-indent': ['error', 2, {
      'baseIndent': 1,
      'switchCase': 1,
      'ignores': []
    }],
    // 强制每行的最大属性数
    'vue/max-attributes-per-line': ['error', {
      'singleline': 1,
      'multiline': {
        'max': 1,
        'allowFirstLine': false
      }
    }],
    // 要求或不允许在标记的右括号前使用换行符
    'vue/html-closing-bracket-newline': ['error', {
      'singleline': 'never',
      'multiline': 'always'
    }],
    // 在标记的右括号前要求或不允许使用空格
    'vue/html-closing-bracket-spacing': 'error',
    // 不允许注册未在模板内使用的组件
    'vue/no-unused-components': 'warn',
    // 不允许v-for指令或作用域属性的未使用变量定义
    'vue/no-unused-vars': 'warn',
    // 禁止使用v-html防止XSS攻击
    'vue/no-v-html': 'off',
    // prop设置默认值
    'vue/require-default-prop': 'off',
    // 'vuetify/no-deprecated-classes': 'error',
    // 'vuetify/grid-unknown-attributes': 'error',
    // 'vuetify/no-legacy-grid': 'error',
    // 添加复杂度
    'complexity': [
      // 圈复杂度最大为10
      'error',
      {
        'max': 10
      }
    ],
    // 强制文件的最大行数
    'max-lines': [
      'error',
      {
        // 单文件最大行数为1000
        'max': 1000,
        'skipComments': true,
        'skipBlankLines': true
      }
    ],
    // 要求必须有基数parseInt 不是必须传入第二个参数
    'radix': 'off',
    // 强制每一行中所允许的最大语句数量
    'max-statements-per-line': [
      'error',
      {
        'max': 1
      }
    ]
  }
}
```

```JavaScript
//.eslintignore 配置检查可忽略的文件
build/*.js
src/assets
public
dist
vue.config.js
jest.config.js
stylelint.config.js
styles_copy2
tests
```

### Lint-staged与husky

lint-staged：确保在暂存文件的时候能够让错误格式代码不会提交到你分支。可以定制在特定的git阶段执行特定的命令

husky：git命令hook专用配置

```
//安装
npm install --save-dev lint-staged husky
	//package.json增加如下配置
	"husky": {    
		"hooks": {      
			"pre-commit": "lint-staged"    
		}  
	},  
	"lint-staged": {
		"*.{html,vue,css,sass,scss}": [
			"stylelint --fix",
			"git add"
		],
		"*.{vue,js}": [
			"vue-cli-service lint",
			"git add"
		],
		"package.json": [
			"sort-package-json"
		]
	}
```

### stylelint

```
// stylelint.config.js stylelint配置

// `.stylelintrc.json`,`.stylelintrc.yaml`,`.stylelintrc.yml`,`.stylelintrc.js`
/**
 * 配置对象
 *
 * stylelint 支持 consmiconfig 的配置方式，按如下顺序查找配置对象：
 *
 * 【】在 package.json 中的 stylelint 属性
 * 【】JSON/YAML/JS 格式的 .stylelintrc 文件（可带后缀）
 * 【】导出 JS 对象的 stylelint.config.js
 */

/**
 * 配置项有：
 * rules: // 规则决定检测器要查找什么和要解决什么。stylelint 有超过 150条规则。属性是个对象，其键为规则名称，值为规则配置。每个规则配置符合以下形式之一：
 * 【】一个值 (主要选项)
 * 【】包含两个值的数组 ([primary option, secondary options])
 * 【】null (关闭规则)
 * extends: // 你的配置可以 extend 一个已存在的配置文件(无论是你自己的还是第三方的配置)。当一个配置继承了里一个配置，它将会添加自己的属性并覆盖原有的属性。
 * plugins: //插件是由社区创建的规则或规则集，支持方法论、工具集，非标准 的 CSS 特性，或非常特定的用例
 * processors: // 是 stylelint 的钩子函数，可以以它的方式修改代码，也可以在它们退出时修改结果.只能用在 命令行 和 Node API，不适用于 PostCSS 插件 (PostCSS 插件将忽略它们。).可以使 stylelint 检测非样式表文件中的 CSS
 * ignoreFiles: // 提供一个 glob 或 globs 数组，忽略特定的文件
 * defaultSeverity: // 只支持 "warning" 和 "error" 两种，用于定义全局默认的报错等级
 */

 /**
  *  stylelint.config.js主要用于解决以下格式问题：
  * 【】不推荐使用 id 选择器来定义样式；
  * 【】多重选择器（multiple selectors）没有换行，不清晰直观；
  * 【】多个 css 规则没有换行，挤在单行太长；
  * 【】使用了 -webkit- 前缀，但是项目中已经支持 autoprefixer ；
  * 【】属性和值之间的空格时有时无等。
  *
  *  rules各项解释请查阅网站：http://stylelint.cn/user-guide/rules
  */
//
module.exports = {
  defaultSeverity: "error",
  extends: ["stylelint-config-standard", 'stylelint-config-prettier'],
  plugins: ["stylelint-scss"],
  rules: {
    // 禁止使用未知的 at 规则
    "at-rule-no-unknown": null,
    // 要求或禁止在 at 规则之前有空行
    "at-rule-empty-line-before": null,
    // 要求或禁止小于 1 的小数的前导 0
    "number-leading-zero": null,
    // 禁止低优先级的选择器出现在高优先级的选择器之后
    "no-descending-specificity": null,
    // 在冒号之后要求有一个换行符或禁止有空白
    "declaration-colon-newline-after": null,
    // 禁止缩写属性覆盖相关普通写法属性
    "declaration-block-no-shorthand-property-overrides": null,
    // 在闭括号之后要求有一个空格或禁止有空格
    "block-closing-brace-space-after": null,
    // 在开括号之前要求有一个空格或禁止有空白
    "block-opening-brace-space-before": null,
    // 不要使用已被 autoprefixer 支持的浏览器前缀
    'media-feature-name-no-vendor-prefix': true,
    // 禁止 at 规则使用浏览器引擎前缀
    'at-rule-no-vendor-prefix': true,
    // 禁止使用浏览器引擎前缀
    'selector-no-vendor-prefix': true,
    // 禁止属性使用浏览器引擎前缀
    'property-no-vendor-prefix': true,
    // 禁止给值添加浏览器引擎前缀
    'value-no-vendor-prefix': true
  }
};
```

## <a href="#plugins" id="plugins">四、项目中应用到的插件</a>

* 工具库函数 https://github.com/HEJIN2016/js-utils
* 轮播插件 swiper https://www.swiper.com.cn/
* 可视化图表插件
	* `echarts` https://www.echartsjs.com
	* `Vue-ECharts` https://github.com/ecomfe/vue-echarts
* g2 http://g2.alipay.com/
* d3.js https://d3js.org/
* highcharts https://www.highcharts.com.cn/
* http请求 axios
* 图片裁切 cropperjs
* 前端div转canvas生成图片 html2canvas
* cookie操作 js-cookie
* 时间操作 moment
* 页面加载进度条 nprogress
* 前端加密 crypto-js
* 代码高亮 highlight.js
* markdown文本转html marked.js
* 前端二维码 qrcode
* 防止 xss攻击 xss
* 前端多语言切换 i18n
* 移动端click点击事件优化 fastclick
* meta操作 vue-meta
* js前端签名 jsignature